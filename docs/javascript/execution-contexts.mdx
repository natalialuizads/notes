---
sidebar_position: 1
---

# Contexto de Execução 

## Definição e Funcionamento
Um **contexto de execução** é uma estrutura abstrata criada pelo motor JavaScript para gerenciar a execução de código. Sempre que qualquer código é executado em um destes ambientes:

- **Global** (script principal)
- **Função** (invocação de função)
- **Módulo** (código modular ES6+)
- **Eval** (execução dinâmica via `eval()`)

um novo contexto é criado. Este contexto é responsável por:

1. Rastrear o ambiente de execução atual
2. Gerenciar variáveis e declarações
3. Controlar o fluxo de execução do código

Os contextos são organizados em uma **pilha de execução (call stack)** seguindo o princípio **LIFO** (Last In, First Out - Último a Entrar, Primeiro a Sair). O contexto no topo da pilha é sempre o ativamente em execução. Quando sua execução termina, ele é removido da pilha e o controle retorna ao contexto anterior.

```mermaid
flowchart TB
    Novo[Novo Contexto Criado] --> Empilha[Empilhado na Call Stack]
    Empilha --> Executa[Execução Iniciada]
    Executa --> Finaliza{Execução Concluída?}
    Finaliza -->|Não| Executa
    Finaliza -->|Sim| Desempilha[Desempilhado da Pilha]
    Desempilha --> Retorna[Controle Retorna ao Contexto Anterior]
```
---
## Registros de Ambiente

### Environment Records: O Sistema de Mapeamento

Os **Environment Records** são estruturas internas definidas pela especificação ECMAScript que:

- **Mapeiam identificadores** (nomes de variáveis/funções) para seus valores
- **Gerenciam associações** entre nomes e valores durante a execução
- **Implementam regras** de escopo léxico e acesso a variáveis

```mermaid
graph TD
    ER[EnvironmentRecord] -->|Implementado por| DER[DeclarativeEnvironmentRecord]
    ER -->|Implementado por| OER[ObjectEnvironmentRecord]
    ER -->|Implementado por| GER[GlobalEnvironmentRecord]
    
    GER -->|Contém| GDER[Declarative Record]
    GER -->|Contém| GOER[Object Record]
    
    DER -->|Especializado em| FER[FunctionEnvironmentRecord]
    DER -->|Especializado em| MER[ModuleEnvironmentRecord]
    
    style ER fill:#4CAF50,stroke:#388E3C
    style GER fill:#2196F3,stroke:#1976D2
    style DER fill:#FF9800,stroke:#F57C00
    style FER fill:#9C27B0,stroke:#7B1FA2
    style MER fill:#009688,stroke:#00796B
    style OER fill:#E91E63,stroke:#C2185B
```

### Global Environment Record: O Gerenciador Híbrido

O **Global Environment Record** gerencia o escopo global usando dois componentes distintos:

```mermaid
graph TD
    GER[Global Environment Record] -->|Combina| DER[Declarative Record]
    GER -->|e| OER[Object Record]
    DER -->|Gerencia| LET["let, const, class"]
    OER -->|Gerencia| VAR["var, function"]
```

### Declarative Environment Record (Componente Global)
Gerencia declarações modernas no escopo global:

**Características**:
- Armazena `let`, `const` e `class`
- Não cria propriedades no objeto global
- Implementa Temporal Dead Zone (TDZ)
- `OuterEnv = null` (fim da cadeia de escopos)

```javascript
let globalLet = "valor";
const GLOBAL_CONST = 10;
class MinhaClasse {}

console.log(globalThis.globalLet); // undefined
console.log(globalThis.MinhaClasse); // undefined
```

### FunctionEnvironmentRecord: Ambiente para Funções

O **FunctionEnvironmentRecord** é uma especialização do DeclarativeEnvironmentRecord que adiciona capacidades para funções:

```mermaid
graph TD
    DER[DeclarativeEnvironmentRecord] --> FER[FunctionEnvironmentRecord]
    FER -->|Adiciona| THIS[Vinculação de this]
    FER -->|Adiciona| ARGS[Objeto arguments]
    FER -->|Adiciona| SUPER[Acesso a super]
```

#### Funcionalidades Essenciais
1. **Vinculação de `this`**:
   ```javascript
   function normalFunc() {
     console.log(this); // Dinâmico (depende da chamada)
   }
   
   const arrowFunc = () => {
     console.log(this); // Léxico (escopo externo)
   };
   ```

2. **Objeto `arguments`**:
   ```javascript
   function soma(a, b) {
     console.log(arguments[0]); // 5 (apenas funções não-arrow)
   }
   soma(5, 10);
   ```

3. **Acesso a `super`**:
   ```javascript
   class Pai {
     metodo() { return "Pai"; }
   }
   
   class Filho extends Pai {
     metodo() {
       return super.metodo() + " > Filho";
     }
   }
   ```

#### Exemplo Completo
```javascript
function criarContador(inicial) {
    // Variáveis gerenciadas pelo FunctionEnvironmentRecord
    let contador = inicial;
    
    return {
        incrementar: () => contador++,
        valor: () => contador,
        // 'this' é acessível
        reset: function() { 
            this.contador = inicial; 
        }
    };
}
```

### ModuleEnvironmentRecord: Ambiente para Módulos ES6

O **ModuleEnvironmentRecord** estende o DeclarativeEnvironmentRecord com:

```mermaid
graph TD
    DER[DeclarativeEnvironmentRecord] --> MER[ModuleEnvironmentRecord]
    MER -->|Adiciona| IMP[Importações]
    MER -->|Adiciona| EXP[Exportações]
```

#### Funcionalidades Principais
1. **Importações imutáveis**:
   ```javascript
   import { API_KEY } from './config.js';
   API_KEY = "novo"; // TypeError: Assignment to constant
   ```

2. **Ligações indiretas**:
   ```javascript
   // contador.js
   export let contador = 0;
   
   // main.js
   import { contador } from './contador.js';
   contador++; // Atualiza a ligação original
   ```

3. **Resolução estática**:
   ```javascript
   // Válido (top-level)
   import { func } from './modulo.js';
   
   // Inválido (condicional)
   if (condicao) {
     import { func } from './modulo.js'; // SyntaxError
   }
   ```

#### Exemplo Completo
```javascript
// math.js (módulo)
export const PI = 3.14159;

export function soma(a, b) {
    return a + b;
}

// app.js (importador)
import { PI, soma } from './math.js';

console.log(soma(PI, 10)); // 13.14159
```

### Object Environment Record (Componente Global)
Gerencia declarações tradicionais no escopo global:

**Características**:
- Armazena `var` e funções declaradas
- Vincula diretamente ao objeto global (`window`/`globalThis`)
- `OuterEnv = null`
- Declarações tornam-se propriedades do objeto global

```javascript
var globalVar = "valor";
function globalFunc() {}

console.log(globalThis.globalVar); // "valor"
console.log(globalThis.globalFunc); // function
```
 
### Tabela Comparativa: Tipos de Registros

| Registro                     | Propósito Principal            | Exemplo de Uso                 | Característica Única               |
|------------------------------|--------------------------------|--------------------------------|------------------------------------|
| **GlobalEnvironmentRecord**  | Escopo global                  | Scripts tradicionais           | Combina dois registros             |
| **DeclarativeEnvironmentRecord** | Escopos de bloco            | `{}`, `if`, `for`             | Gerencia `let`/`const` com TDZ     |
| **FunctionEnvironmentRecord** | Funções e métodos             | `function(){}`, `() => {}`     | Gerencia `this`, `arguments`       |
| **ModuleEnvironmentRecord**  | Módulos ES6                   | `import`/`export`              | Ligações imutáveis para imports    |
| **ObjectEnvironmentRecord**  | Vinculação a objetos          | Contexto global, `with`        | Acesso direto a propriedades       |

---

## OuterEnv: O Coração das Closures

### Mecanismo Fundamental
Todo registro de ambiente possui um campo **`OuterEnv`** que referencia seu ambiente pai, formando a **cadeia de escopos** (scope chain). 

**Processo de resolução de identificadores**:
1. Busca começa no registro atual
2. Se não encontrado, segue a referência `OuterEnv`
3. Repete até encontrar o identificador ou chegar ao escopo global (`OuterEnv = null`)
4. Identificador inexistente resulta em `ReferenceError`

```javascript
function externo() {
    const externoVar = 10; // No registro de 'externo'
    
    function interno() {
        // Pode acessar externoVar via OuterEnv
        console.log(externoVar);
    }
    
    return interno;
}

const closure = externo();
closure(); // Mantém acesso ao OuterEnv mesmo após execução
```

## Componentes do Contexto Global

### Estado de Avaliação de Código
Mecanismo que mantém o estado de execução para recursos complexos:

| Recurso                | Funcionalidade                  | Exemplo Prático               |
|------------------------|--------------------------------|-------------------------------|
| **Async/Await**        | Suspensão e retomada de contexto| `async function fetchData()`  |
| **Geradores**          | Controle de estado entre yield  | `function* generator()`      |
| **Depuração**          | Gerenciamento de breakpoints    | Pausa no DevTools            |
| **Tratamento de Erros**| Rastreamento da pilha de chamadas| `new Error().stack`          |

### Realm: Domínio de Execução Isolado

#### Conceito Fundamental
Um **Realm** é um ambiente de execução completamente isolado que funciona como um "container" independente para código JavaScript. Este mecanismo garante:

1. **Isolamento total**: Código em diferentes Realms não interfere entre si
2. **Segurança**: Previne acesso não autorizado entre contextos
3. **Estabilidade**: Falhas em um Realm não afetam outros

**Exemplo prático**: Quando você abre uma nova aba no navegador, um novo Realm é criado automaticamente. Isso significa que:

```javascript
// Tab 1 (www.site-a.com)
window.appData = { usuario: "João" };

// Tab 2 (www.site-b.com)
console.log(window.appData); // undefined - Realms diferentes!
```

#### Componentes Essenciais
Cada Realm possui três elementos fundamentais:

#### Objetos Intrínsecos (Intrinsics)
São as implementações padrão das funcionalidades básicas da linguagem:

```mermaid
graph LR
    I[Objetos Intrínsecos] --> F[Fundamentos: Object, Function, Array]
    I --> E[Erros: Error, TypeError]
    I --> T[Temporais: Date]
    I --> M[Matemática: Math]
    I --> C[Coleções: Map, Set]
    I --> P[Promises e Async]
```

**Características principais**:
- São criados antes da execução de qualquer código
- Implementações independentes por Realm
- Acessíveis via objeto global (ex: `window.Array`)

#### Objeto Global

O **Objeto Global** é uma instância fundamental que serve como ponto de acesso principal dentro de um Realm. Mais do que um simples "objeto literal", ele funciona como:

1. **Container raiz** para todas as variáveis globais
2. **Ponto de entrada** para funcionalidades do ambiente
3. **Interface universal** entre JavaScript e o ambiente host

**Implementações por ambiente**:
| Ambiente       | Objeto Global | Acesso Universal       |
|----------------|---------------|------------------------|
| Navegador      | `window`      | `globalThis`           |
| Node.js        | `global`      | `globalThis`           |
| Web Workers    | `self`        | `globalThis`           |
| Deno           | `globalThis`  | `globalThis`           |
| Módulos ES6    | `<module>`    | `globalThis`           |

> **Nota**: `globalThis` (ES2020) é o padrão cross-platform para acesso seguro ao objeto global em qualquer ambiente.

#### Anatomia do Objeto Global

##### Propriedades de Especificação (Intrinsic Properties)
São os objetos e funções definidos pelo **padrão ECMAScript** que formam o núcleo da linguagem:

```javascript
// Exemplos fundamentais
globalThis.Array    // Construtor de arrays
globalThis.Date     // Manipulação de datas
globalThis.JSON     // Serialização de objetos
globalThis.Math     // Operações matemáticas
globalThis.SyntaxError // Construtor de erros
```

**Características principais**:
- Implementadas diretamente pelo motor JavaScript
- Seguem rigorosamente a especificação ECMAScript
- Não podem ser deletadas ou reconfiguradas
- São idênticas em conceito entre ambientes (mas implementações podem variar)

##### Propriedades do Host (Host-Defined Properties)
Funcionalidades específicas do **ambiente de execução**:

```javascript
// Navegador
globalThis.document     // Árvore DOM completa
globalThis.location     // Informações de URL
globalThis.history      // Navegação entre páginas
globalThis.fetch        // API de requisições HTTP
globalThis.localStorage // Armazenamento persistente

// Node.js
globalThis.process      // Informações do processo
globalThis.__filename   // Caminho do arquivo atual
globalThis.Buffer       // Manipulação de binários
globalThis.require      // Sistema de módulos
```

**Comportamento importante**:
- Não padronizadas pela ECMAScript
- Podem variar significativamente entre ambientes
- Normalmente são somente-leitura
- Refletem capacidades específicas da plataforma

##### Propriedades do Usuário (User-Defined Properties)
Variáveis e funções adicionadas por **desenvolvedores**:

**Adição explícita** (recomendada):
```javascript
// Definição direta
globalThis.appConfig = {
  environment: 'production',
  version: '2.3.0',
  apiUrl: 'https://api.meudominio.com'
};

// Acesso em qualquer escopo
function fetchData() {
  return fetch(globalThis.appConfig.apiUrl);
}
```

**Adição implícita** (através de declarações globais):
```javascript
// Variável 'var' torna-se propriedade
var globalCounter = 0; 
console.log(globalThis.globalCounter); // 0

// Funções declaradas
function formatCurrency(value) {
  return `R$ ${value.toFixed(2)}`;
}
globalThis.formatCurrency(199.9); // "R$ 199.90"

// Perigo: atribuição sem declaração
globalVariable = 10; // Cria propriedade no objeto global!
console.log(globalThis.globalVariable); // 10
```

#### Mecanismos de Adição: Explicação Técnica

```mermaid
flowchart TB
    D[Declaração] --> T{Tipo}
    T -->|&quot;var&quot;| G[Propriedade no Objeto Global]
    T -->|function| G
    T -->|let/const| N[Não adiciona ao Global Object]
    T -->|Atribuição sem declaração| G
    
    A[Acesso] --> M{Modo}
    M -->|Browser| W[window.propriedade]
    M -->|Node.js| N[global.propriedade]
    M -->|Universal| GT[globalThis.propriedade]
```

#### Tabela Comparativa de Comportamento

| Tipo de Declaração | Torna-se Propriedade | Escopo        | Hoisting | Pode ser Deletada? |
|--------------------|----------------------|---------------|----------|-------------------|
| **var**            | Sim                  | Função/Global | Sim      | Não               |
| **function**       | Sim                  | Global        | Sim      | Não               |
| **let/const**      | Não                  | Bloco         | Parcial  | -                 |
| **Atribuição direta** | Sim               | Global        | Não      | Sim               |

### Ambientes Léxico e de Variáveis: Os Dois Pilares da Execução

Todo contexto de execução em JavaScript possui **dois componentes ambientais** que trabalham em conjunto para gerenciar variáveis e declarações:

```mermaid
graph TD
    EC[Contexto de Execução] --> LE[LexicalEnvironment]
    EC --> VE[VariableEnvironment]
    
    LE -->|Inicialmente| VE
    LE -->|Pode divergir| NovoLE[Novo Environment Record]
```

### LexicalEnvironment: O Ambiente Dinâmico

O **LexicalEnvironment** é o componente que:

1. **Aponta para** o Environment Record atual do contexto
2. **Gerencia** declarações com escopo léxico preciso
3. **Muda dinamicamente** durante a execução

##### Conteúdo e Comportamento
| Tipo de Declaração      | Comportamento                   | Exemplo                  |
|-------------------------|--------------------------------|--------------------------|
| **`let`**               | Escopo de bloco, sujeito a TDZ  | `let x = 10;`           |
| **`const`**             | Escopo de bloco, imutável       | `const PI = 3.14;`      |
| **Classes**             | Escopo de bloco, hoisted parcial| `class MinhaClasse {}`  |
| **Módulos (import/export)**| Escopo de módulo             | `import { x } from 'mod'` |
| **Parâmetros de função**| Escopo de função               | `function(a, b) {}`     |

**Características principais**:
- **Temporal Dead Zone (TDZ)**: Acesso antes da declaração causa erro
  ```javascript
  console.log(a); // ReferenceError
  let a = 10;
  ```
- **Mutabilidade**: Pode ser substituído durante a execução
  ```javascript
  function exemplo() {
    // Ambiente léxico inicial
    
    {
      // Novo ambiente léxico criado para o bloco
      let x = 20;
    }
  }
  ```
- **Sombreamento (Shadowing)**:
  ```javascript
  let x = "global";
  
  {
    let x = "bloco"; // Sombreia a variável externa
    console.log(x); // "bloco"
  }
  
  console.log(x); // "global"
  ```

### VariableEnvironment: O Ambiente Estático

O **VariableEnvironment** é o componente que:
1. **Aponta permanentemente** para o Environment Record inicial
2. **Gerencia** declarações tradicionais com hoisting
3. **Permanece imutável** durante toda a execução

#### Conteúdo e Comportamento
| Tipo de Declaração      | Comportamento                   | Exemplo                  |
|-------------------------|--------------------------------|--------------------------|
| **`var`**               | Escopo de função/global        | `var y = 20;`           |
| **Funções declaradas**  | Hoisting completo               | `function z() {}`       |
| **Funções async**       | Hoisting completo               | `async function w() {}` |

**Características principais**:
- **Hoisting Completo**: Declarações são movidas para o topo do escopo
  ```javascript
  console.log(b); // undefined (não erro!)
  var b = 10;
  ```
- **Imutabilidade**: Mantém a mesma referência durante toda execução
  ```javascript
  function exemplo() {
    var c = 10;
    
    {
      // Mesmo VariableEnvironment!
      var c = 20; 
    }
    
    console.log(c); // 20
  }
  ```
- **Sem TDZ**: Variáveis são inicializadas com `undefined`
  ```javascript
  console.log(d); // undefined
  var d = 30;
  ```

### Relação Entre LexicalEnvironment e VariableEnvironment

### Fase de Criação do Contexto
```mermaid
sequenceDiagram
    participant EC as Contexto de Execução
    participant LE as LexicalEnvironment
    participant VE as VariableEnvironment
    
    EC->>LE: Cria apontando para Environment Record
    EC->>VE: Cria apontando para o MESMO Environment Record
    Note over LE,VE: Ambos idênticos inicialmente
```

### Durante a Execução
```mermaid
sequenceDiagram
    participant C as Código
    participant LE as LexicalEnvironment
    participant VE as VariableEnvironment
    
    C->>C: Entra em bloco (try/catch, loop, etc.)
    C->>LE: Substitui por novo Environment Record
    Note over VE: Permanece inalterado
    C->>C: Executa código no bloco
    C->>C: Sai do bloco
    C->>LE: Restaura Environment Record anterior
```

### Casos Especiais e Comportamentos Críticos

### 1. Blocos `try/catch`
```javascript
let externo = "valor";

try {
    throw new Error();
} catch (erro) { // Novo LexicalEnvironment criado
    let interno = "bloco";
    var vazando = "vaza"; // VariableEnvironment (escopo externo)
    
    console.log(erro.message); // Acessível
}

console.log(vazando); // "vaza" (var vaza)
console.log(erro);    // ReferenceError (erro não acessível)
console.log(interno); // ReferenceError
```

### 2. Loops com `let` vs `var`
```javascript
// Com let (novo LexicalEnvironment por iteração)
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 0); // 0, 1, 2
}

// Com var (mesmo VariableEnvironment)
for (var j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 0); // 3, 3, 3
}
```

### 3. Funções dentro de blocos
```javascript
if (true) {
    function declarada() { return "bloco"; }
    let expressada = function() { return "expressão"; }
}

console.log(declarada()); // "bloco" (hoisting do VariableEnvironment)
console.log(expressada); // ReferenceError (let tem escopo de bloco)
```

### Tabela Comparativa: LexicalEnvironment vs VariableEnvironment

| Característica          | LexicalEnvironment                          | VariableEnvironment                 |
|-------------------------|---------------------------------------------|-------------------------------------|
| **Flexibilidade**       | Dinâmico (muda em blocos)                   | Estático (fixo)                    |
| **Ciclo de Vida**       | Temporário para blocos                      | Permanente durante o contexto       |
| **TDZ (Temporal Dead Zone)** | Sim                                      | Não                                 |
| **Hoisting**            | Parcial (declarado mas não inicializado)    | Completo (inicializado como `undefined`) |
| **Tipos de Declarações**| `let`, `const`, classes, parâmetros, imports | `var`, declarações `function`      |
| **Exemplo Crítico**     | `catch(e)`, `for(let...)`                   | `var` em blocos, funções declaradas |
